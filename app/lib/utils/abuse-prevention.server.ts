import { prisma } from "~/lib/db/db.server";
import { logChatAuditEvent } from "./audit-logging.server";
import { detectSpam, detectProfanity, detectSuspiciousPatterns } from "../chat-security.server";

export interface AbuseReport {
  id: string;
  reporterId: string;
  reportedUserId: string;
  messageId?: string;
  conversationId?: string;
  reason: 'spam' | 'harassment' | 'inappropriate' | 'scam' | 'other';
  description: string;
  status: 'pending' | 'reviewed' | 'resolved' | 'dismissed';
  adminNotes?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface AbusePattern {
  userId: string;
  pattern: string;
  count: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  detectedAt: Date;
}

/**
 * Report abuse in a message or conversation
 */
export async function reportAbuse(
  reporterId: string,
  reportedUserId: string,
  reason: AbuseReport['reason'],
  description: string,
  options: {
    messageId?: string;
    conversationId?: string;
  } = {}
): Promise<AbuseReport> {
  const report = await prisma.abuseReport.create({
    data: {
      reporterId,
      reportedUserId,
      messageId: options.messageId,
      conversationId: options.conversationId,
      reason,
      description,
      status: 'pending',
    },
  });

  // Log the abuse report
  await logChatAuditEvent(
    reporterId,
    'abuse_reported',
    {
      reportedUserId,
      reason,
      description,
      messageId: options.messageId,
      conversationId: options.conversationId,
    },
    {
      targetUserId: reportedUserId,
      severity: 'medium',
    }
  );

  // Check if user should be auto-flagged
  await checkForAutoFlagging(reportedUserId);

  return report;
}

/**
 * Check for auto-flagging based on abuse patterns
 */
async function checkForAutoFlagging(userId: string): Promise<void> {
  const recentReports = await prisma.abuseReport.count({
    where: {
      reportedUserId: userId,
      createdAt: {
        gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours
      },
    },
  });

  const recentMessages = await prisma.supportMessage.findMany({
    where: {
      senderId: userId,
      createdAt: {
        gte: new Date(Date.now() - 60 * 60 * 1000), // Last hour
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
    take: 10,
  });

  // Check for spam patterns
  const messageContents = recentMessages.map(msg => msg.content);
  const isSpam = detectSpam(messageContents, userId);

  if (isSpam) {
    await flagUserForSpam(userId, 'Detected spam patterns in recent messages');
  }

  // Check for profanity
  const profanityDetected = messageContents.some(content => 
    detectProfanity(content).length > 0
  );

  if (profanityDetected) {
    await flagUserForProfanity(userId, 'Profanity detected in messages');
  }

  // Check for suspicious patterns
  const suspiciousPatterns = messageContents.some(content =>
    detectSuspiciousPatterns(content).length > 0
  );

  if (suspiciousPatterns) {
    await flagUserForSuspiciousActivity(userId, 'Suspicious patterns detected');
  }

  // Auto-flag if multiple reports
  if (recentReports >= 3) {
    await flagUserForMultipleReports(userId, `Received ${recentReports} abuse reports in 24 hours`);
  }
}

/**
 * Flag user for spam
 */
async function flagUserForSpam(userId: string, reason: string): Promise<void> {
  await prisma.userFlag.create({
    data: {
      userId,
      flagType: 'spam',
      reason,
      severity: 'medium',
      autoGenerated: true,
    },
  });

  await logChatAuditEvent(
    'system',
    'user_flagged',
    {
      userId,
      flagType: 'spam',
      reason,
    },
    {
      targetUserId: userId,
      severity: 'medium',
    }
  );
}

/**
 * Flag user for profanity
 */
async function flagUserForProfanity(userId: string, reason: string): Promise<void> {
  await prisma.userFlag.create({
    data: {
      userId,
      flagType: 'profanity',
      reason,
      severity: 'low',
      autoGenerated: true,
    },
  });

  await logChatAuditEvent(
    'system',
    'user_flagged',
    {
      userId,
      flagType: 'profanity',
      reason,
    },
    {
      targetUserId: userId,
      severity: 'low',
    }
  );
}

/**
 * Flag user for suspicious activity
 */
async function flagUserForSuspiciousActivity(userId: string, reason: string): Promise<void> {
  await prisma.userFlag.create({
    data: {
      userId,
      flagType: 'suspicious',
      reason,
      severity: 'high',
      autoGenerated: true,
    },
  });

  await logChatAuditEvent(
    'system',
    'user_flagged',
    {
      userId,
      flagType: 'suspicious',
      reason,
    },
    {
      targetUserId: userId,
      severity: 'high',
    }
  );
}

/**
 * Flag user for multiple reports
 */
async function flagUserForMultipleReports(userId: string, reason: string): Promise<void> {
  await prisma.userFlag.create({
    data: {
      userId,
      flagType: 'multiple_reports',
      reason,
      severity: 'high',
      autoGenerated: true,
    },
  });

  await logChatAuditEvent(
    'system',
    'user_flagged',
    {
      userId,
      flagType: 'multiple_reports',
      reason,
    },
    {
      targetUserId: userId,
      severity: 'high',
    }
  );
}

/**
 * Get abuse reports for admin review
 */
export async function getAbuseReports(
  options: {
    status?: string;
    reason?: string;
    startDate?: Date;
    endDate?: Date;
    limit?: number;
  } = {}
) {
  const where: any = {};

  if (options.status) {
    where.status = options.status;
  }
  if (options.reason) {
    where.reason = options.reason;
  }
  if (options.startDate) {
    where.createdAt = { ...where.createdAt, gte: options.startDate };
  }
  if (options.endDate) {
    where.createdAt = { ...where.createdAt, lte: options.endDate };
  }

  return await prisma.abuseReport.findMany({
    where,
    include: {
      reporter: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
      reportedUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
      message: {
        select: {
          id: true,
          content: true,
          createdAt: true,
        },
      },
      conversation: {
        select: {
          id: true,
          title: true,
          ticketNumber: true,
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
    take: options.limit || 100,
  });
}

/**
 * Update abuse report status
 */
export async function updateAbuseReportStatus(
  reportId: string,
  status: AbuseReport['status'],
  adminId: string,
  adminNotes?: string
): Promise<void> {
  await prisma.abuseReport.update({
    where: { id: reportId },
    data: {
      status,
      adminNotes,
      updatedAt: new Date(),
    },
  });

  await logChatAuditEvent(
    adminId,
    'abuse_report_updated',
    {
      reportId,
      status,
      adminNotes,
    },
    {
      severity: 'medium',
    }
  );
}

/**
 * Get user's abuse history
 */
export async function getUserAbuseHistory(userId: string) {
  const [reports, flags, violations] = await Promise.all([
    prisma.abuseReport.findMany({
      where: { reportedUserId: userId },
      include: {
        reporter: {
          select: {
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    }),
    prisma.userFlag.findMany({
      where: { userId },
      orderBy: {
        createdAt: 'desc',
      },
    }),
    prisma.userViolation.findMany({
      where: { userId },
      orderBy: {
        createdAt: 'desc',
      },
    }),
  ]);

  return {
    reports,
    flags,
    violations,
    totalReports: reports.length,
    totalFlags: flags.length,
    totalViolations: violations.length,
  };
}

/**
 * Create user violation
 */
export async function createUserViolation(
  userId: string,
  violationType: string,
  reason: string,
  adminId: string,
  duration?: number
): Promise<void> {
  await prisma.userViolation.create({
    data: {
      userId,
      violationType,
      reason,
      adminId,
      duration,
      status: 'active',
    },
  });

  await logChatAuditEvent(
    adminId,
    'user_violation_created',
    {
      userId,
      violationType,
      reason,
      duration,
    },
    {
      targetUserId: userId,
      severity: 'high',
    }
  );
}

/**
 * Suspend user
 */
export async function suspendUser(
  userId: string,
  reason: string,
  duration: number,
  adminId: string
): Promise<void> {
  const suspendedUntil = new Date(Date.now() + duration * 60 * 60 * 1000);

  await prisma.user.update({
    where: { id: userId },
    data: {
      suspendedUntil,
      suspensionReason: reason,
    },
  });

  await createUserViolation(
    userId,
    'suspension',
    reason,
    adminId,
    duration
  );

  await logChatAuditEvent(
    adminId,
    'user_suspended',
    {
      userId,
      reason,
      duration,
      suspendedUntil,
    },
    {
      targetUserId: userId,
      severity: 'critical',
    }
  );
}

/**
 * Ban user permanently
 */
export async function banUser(
  userId: string,
  reason: string,
  adminId: string
): Promise<void> {
  await prisma.user.update({
    where: { id: userId },
    data: {
      banned: true,
      banReason: reason,
      bannedAt: new Date(),
    },
  });

  await createUserViolation(
    userId,
    'ban',
    reason,
    adminId
  );

  await logChatAuditEvent(
    adminId,
    'user_banned',
    {
      userId,
      reason,
    },
    {
      targetUserId: userId,
      severity: 'critical',
    }
  );
}

/**
 * Get flagged users for admin review
 */
export async function getFlaggedUsers(
  options: {
    flagType?: string;
    severity?: string;
    startDate?: Date;
    endDate?: Date;
    limit?: number;
  } = {}
) {
  const where: any = {};

  if (options.flagType) {
    where.flagType = options.flagType;
  }
  if (options.severity) {
    where.severity = options.severity;
  }
  if (options.startDate) {
    where.createdAt = { ...where.createdAt, gte: options.startDate };
  }
  if (options.endDate) {
    where.createdAt = { ...where.createdAt, lte: options.endDate };
  }

  return await prisma.userFlag.findMany({
    where,
    include: {
      user: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          createdAt: true,
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
    take: options.limit || 100,
  });
}

/**
 * Detect harassment patterns
 */
export async function detectHarassmentPatterns(
  userId: string,
  targetUserId: string
): Promise<boolean> {
  const recentMessages = await prisma.supportMessage.findMany({
    where: {
      senderId: userId,
      ticket: {
        providerId: targetUserId,
      },
      createdAt: {
        gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
    take: 20,
  });

  // Check for aggressive tone patterns
  const aggressivePatterns = [
    /(?:fuck|shit|damn|bitch|asshole)/i,
    /(?:kill|hurt|destroy|ruin)/i,
    /(?:hate|despise|loathe)/i,
    /(?:stupid|idiot|moron|dumb)/i,
  ];

  const aggressiveCount = recentMessages.filter(msg =>
    aggressivePatterns.some(pattern => pattern.test(msg.content))
  ).length;

  // Check for message frequency
  const messageFrequency = recentMessages.length;
  const timeSpan = 24 * 60 * 60 * 1000; // 24 hours
  const messagesPerHour = messageFrequency / (timeSpan / (60 * 60 * 1000));

  // Flag if aggressive messages > 30% or messages > 10 per hour
  return aggressiveCount / recentMessages.length > 0.3 || messagesPerHour > 10;
}

/**
 * Get abuse statistics
 */
export async function getAbuseStatistics(
  startDate?: Date,
  endDate?: Date
) {
  const where: any = {};
  if (startDate) {
    where.createdAt = { ...where.createdAt, gte: startDate };
  }
  if (endDate) {
    where.createdAt = { ...where.createdAt, lte: endDate };
  }

  const [
    totalReports,
    reportsByReason,
    reportsByStatus,
    flaggedUsers,
    violations
  ] = await Promise.all([
    prisma.abuseReport.count({ where }),
    prisma.abuseReport.groupBy({
      by: ['reason'],
      where,
      _count: { reason: true },
    }),
    prisma.abuseReport.groupBy({
      by: ['status'],
      where,
      _count: { status: true },
    }),
    prisma.userFlag.count({ where }),
    prisma.userViolation.count({ where }),
  ]);

  return {
    totalReports,
    reportsByReason,
    reportsByStatus,
    flaggedUsers,
    violations,
  };
}
